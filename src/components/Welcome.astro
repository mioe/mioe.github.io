<script>
	let windowManager;
	let initialized = false;

	let sceneOffsetTarget = { x: 0, y: 0 }
	let sceneOffset = { x: 0, y: 0 }

	class WindowManager {
		#windows;
		#count;
		#id;
		#winData;
		#winShapeChangeCallback;
		#winChangeCallback;

		constructor() {
			let that = this;

			// event listener for when localStorage is changed from another window
			addEventListener("storage", (event) => {
				if (event.key == "windows") {
					let newWindows = JSON.parse(event.newValue);
					let winChange = that.#didWindowsChange(that.#windows, newWindows);

					that.#windows = newWindows;

					if (winChange) {
						if (that.#winChangeCallback) that.#winChangeCallback();
					}
				}
			});

			// event listener for when current window is about to ble closed
			window.addEventListener("beforeunload", function (e) {
				let index = that.getWindowIndexFromId(that.#id);

				//remove this window from the list and update local storage
				that.#windows.splice(index, 1);
				that.updateWindowsLocalStorage();
			});
		}

		// check if theres any changes to the window list
		#didWindowsChange(pWins, nWins) {
			if (pWins.length != nWins.length) {
				return true;
			} else {
				let c = false;

				for (let i = 0; i < pWins.length; i++) {
					if (pWins[i].id != nWins[i].id) c = true;
				}

				return c;
			}
		}

		// initiate current window (add metadata for custom data to store with each window instance)
		init(metaData) {
			this.#windows = JSON.parse(localStorage.getItem("windows")) || [];
			this.#count = localStorage.getItem("count") || 0;
			this.#count++;

			this.#id = this.#count;
			let shape = this.getWinShape();
			this.#winData = { id: this.#id, shape: shape, metaData: metaData };
			this.#windows.push(this.#winData);

			localStorage.setItem("count", this.#count);
			this.updateWindowsLocalStorage();
		}

		getWinShape() {
			let shape = {
				x: window.screenLeft,
				y: window.screenTop,
				w: window.innerWidth,
				h: window.innerHeight,
			};
			return shape;
		}

		getWindowIndexFromId(id) {
			let index = -1;

			for (let i = 0; i < this.#windows.length; i++) {
				if (this.#windows[i].id == id) index = i;
			}

			return index;
		}

		updateWindowsLocalStorage() {
			localStorage.setItem("windows", JSON.stringify(this.#windows));
		}

		update() {
			//console.log(step);
			let winShape = this.getWinShape();

			console.log(winShape.x, winShape.y);

			if (
				winShape.x != this.#winData.shape.x ||
				winShape.y != this.#winData.shape.y ||
				winShape.w != this.#winData.shape.w ||
				winShape.h != this.#winData.shape.h
			) {
				this.#winData.shape = winShape;

				let index = this.getWindowIndexFromId(this.#id);
				this.#windows[index].shape = winShape;

				if (this.#winShapeChangeCallback) this.#winShapeChangeCallback();
				this.updateWindowsLocalStorage();
			}
		}

		setWinShapeChangeCallback(callback) {
			this.#winShapeChangeCallback = callback;
		}

		setWinChangeCallback(callback) {
			this.#winChangeCallback = callback;
		}

		getWindows() {
			return this.#windows;
		}

		getThisWindowData() {
			return this.#winData;
		}

		getThisWindowID() {
			return this.#id;
		}
	}

	if (new URLSearchParams(window.location.search).get('clear')) {
		localStorage.clear();
	} else {
		// this code is essential to circumvent that some browsers preload the content of some pages before you actually hit the url
		document.addEventListener("visibilitychange", () => {
			if (document.visibilityState != 'hidden' && !initialized) {
				init();
			}
		});

		window.onload = () => {
			if (document.visibilityState != 'hidden') {
				init();
			}
		};

		function init () {
			initialized = true;

			// add a short timeout because window.offsetX reports wrong values before a short period
			setTimeout(() => {
				setupWindowManager();
				resize();
				updateWindowShape(false);
				window.addEventListener('resize', resize);
			}, 500)
		}

		function updateWindowShape (easing = true) {
			console.log('ðŸ¦• updateWindowShape')
			// storing the actual offset in a proxy that we update against in the render function
			sceneOffsetTarget = { x: -window.screenX, y: -window.screenY }
			if (!easing) {
				sceneOffset = sceneOffsetTarget
			}
		}

		function windowsUpdated () {
			console.log('ðŸ¦• windowsUpdated')
		}

		function resize () {
			let width = window.innerWidth;
			let height = window.innerHeight

			console.log('ðŸ¦• width', width)
			console.log('ðŸ¦• height', height)
		}

		function setupWindowManager () {
			windowManager = new WindowManager();
			windowManager.setWinShapeChangeCallback(updateWindowShape);
			windowManager.setWinChangeCallback(windowsUpdated);

			// here you can add your custom metadata to each windows instance
			let metaData = {foo: "bar"};

			// this will init the windowmanager and add this window to the centralised pool of windows
			windowManager.init(metaData);

			// call update windows initially (it will later be called by the win change callback)
			windowsUpdated();
		}
	}
</script>

<article>
	<p>mioe</p>
</article>

<style>
	article {
		display: flex;
		align-items: center;
		justify-content: center;
		min-height: 100vh;
	}
</style>
